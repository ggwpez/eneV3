#include <fstream>
#include <iostream>
#include <string>

#include "compiler.h"
#include "io.h"
#include "warnings.h"
#include "errors.hpp"
#include "target.h"

compiler::compiler(size_t bits)
{
    this->output = new std::wostringstream();

    switch (bits)
    {
        case 64:
            target = &target64;
            break;
        case 32:
            target = &target32;
            break;
        case 16:
            target = &target16;
            break;
        default:
            ERR(err_t::CMP_BITS_UNSUPP, bits);
            break;
    }
}

void compiler::compile(char* file_name, char* output_file_name)
{
    war_init();

    //std::wcout << "Lexing...";
    lexer lex = lexer(file_name);
    std::vector<tok*>* toks = lex.lex();

    //std::wcout << "Done." << std::endl << "Parsing...";
    parser par = parser(*toks);
    uast* un_ast = par.parse();

    //std::wcout << "Done." << std::endl << "Type generation...";
    scope* sc = new scope();
    scoper* scr = new scoper(un_ast, sc);
    ProgramNode* ast = scr->convert();

    //std::wcout << "Done." << std::endl << "Code generation...";
    this->load_template();
    il* gen = new il(ast, this->output);
    gen->generate();
    war_dump(std::wcout);

    delete gen;
    delete ast;
    delete scr;
    delete sc;
    for (tok* t : *toks)
        delete t;
    delete toks;
    //std::wcout << "Done." << std::endl;

    post_process(output_file_name);
}

void compiler::post_process(char* output_file_name)
{
    write_wstr(output_file_name);

    std::stringstream nasm, gcc;
    nasm << "nasm -f elf" << __BITS__ << " " << output_file_name << " -o " << output_file_name << ".obj";
    gcc  << "gcc -m" << __BITS__ << " " << output_file_name << ".obj" << " -o " << output_file_name << ".out";

    if (system(nasm.str().c_str()))
        ERR(err_t::POST_PROCESSING_FAILED);
    if (system(gcc.str().c_str()))
        ERR(err_t::POST_PROCESSING_FAILED);
}

void compiler::write_wstr(char* file_name)
{
    std::wofstream f;
    f.open(file_name);
    f << this->output->str();

    f.close();
}

void compiler::write_str(char* file_name)
{
    std::string str = std::string(this->output->str().begin(), this->output->str().end());
    std::ofstream f;
    f.open(file_name);
    f << str;

    f.close();
}

void compiler::load_template()
{
    io helper;
    std::string tem_path = std::string("../src/template_") + std::to_string(target->bits) + std::string(".nasm");

    *this->output << L"; generated by the ene compiler version 3.0 " << std::endl <<
                     L"; build on " << __DATE__ << L' ' << __TIME__ << std::endl << std::endl <<
                     L"; ### TEMPLATE BEGIN ###" << std::endl;

    helper.read_file(tem_path.c_str(), this->output);
    *this->output << L"; ### TEMPLATE   END ###" << std::endl << std::endl << std::endl;
}
